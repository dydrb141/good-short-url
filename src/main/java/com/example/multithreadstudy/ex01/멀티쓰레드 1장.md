**멀티스레드 쓰레드 프로그램(multithreaded program)**

- 여러 개의 쓰레드로 구성된 프로그램



**strart 메소드는  Thread 클래스의 메소드임**

start를 호출하면?

- 새로운 쓰레드 기동
- run 메소드 호출



**순차(sequential) :** 

- 복수의 업무를 순서대로 처리
- 한 명이 10개의 업무를 처리할 때 그 사람의 업무를 순차적으로 처리

**병렬(parallel) :** 

- 복수의 업무를 동시에 처리
- 10개의 업무를 2명이 분담하여 처리 하는 이치

**병행(concurrent) :** 

- 한 개의 업무를 어떠한 순서로 처리하든 상관 없는 여러 개의 작업 으로 분할하는 모습
- 10개의 업무를 2종류의 독립된 작업으로 분할해 두면 병행 처리 작업 끝
- 작업자(cpu)가 한명이라면 분할해둔 작업을 순차로 처리, 작업자가 두 명이라면 같은 작업을 병렬로 처리



**쓰레드를 기동하는 방법 2가지**

- Thread 클래스의 서브 클래스 인스턴스를 사용하여 기동
- Runnable 인터페이스의 구현 클래스 인터페이스를 사용하여 기동



**데이터 레이스(Data Race) OR 레이스 컨디션(Race Condition)**

- A쓰레드와 B 쓰레드가 있을 때 A쓰레드가 처리하고 있을 때 B쓰레드가 끼어들 가능성이 있는 로직



**베타제어 OR 상호배타 (Mutual Exclusion)**

- 레이스 컨디션을 방지 함.
- Java에서는 Synchronized 키워드를 사용



**Synchronized**

- 한 번에 하나의 쓰레드만 실행 



**모든 인스턴스는 wait set을 가짐**

wait set - 인스턴스의 wait 메소드를 실핸한 후 동작을 정지하고 있는 쓰레드의 집합

wait 메소드를 실행하면 동작을 일시 정지하고 wait 셋에 들어가게 됨.



**wait set에 나오는 조건**

- 다른 쓰레드에서 notify 메소드에 의해 깨어난다
- 다른 쓰레드에서 notifyAll 메소드에 의해 깨어난다
- 다른 쓰레드에서 interrupt 메소드에 의해 깨어난다
- wait 메소드가 타임아웃 된다.



**notify**

- wait 셋에 있는 쓰레드 한 개를 wait 셋에서 꺼냄
- notify를 한 순간 실행을 재개 하는건 아님



**notifyAll**

- wait셋에 있는 모든 쓰레드를 wait셋에서 꺼냄
- notify는 한개의 쓰레드만 깨우는 반면 notifyAll은 모든 쓰레드를 깨움



**notify메소드와 notifyAll중 어느것을 사용해야하나**

- notify이 빠름 (깨울 쓰레드가 적기 때문)
- notify는 이용방법에 따라 멈춰버릴 위험이 있음
- notifyAll을 사용하면 코드가 견고해짐



![쓰레드 상태 변화](https://t1.daumcdn.net/cfile/tistory/99BAE2335B4DBC5834)





